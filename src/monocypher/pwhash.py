import re
from base64 import b64encode, b64decode
from monocypher.utils import ensure, ensure_bytes, random, ensure_range
from monocypher.utils.crypto_pwhash import crypto_argon2i
from monocypher.utils.crypto_cmp import crypto_verify32, crypto_verify16, crypto_verify64


__all__ = ('pwhash', 'verify', 'argon2i')


argon2i_phc_format = re.compile(r'^\$argon2i\$v=19\$m=([0-9]{1,10}),t=([0-9]{1,10}),p=1\$([a-zA-Z0-9+/]{11,64})\$([a-zA-Z0-9+/]{16,86})$')


def _encode_base64(data):
    return b64encode(data).rstrip(b'=').decode('ascii')


def _decode_base64(data):
    missing_padding = len(data) % 4
    if missing_padding:
        data += '=' * (4 - missing_padding)
    return b64decode(data)


argon2i = crypto_argon2i


class UnsupportedHashError(Exception):
    pass


def pwhash(password, salt=None, nb_blocks=100000, nb_iterations=3, hash_size=32):
    """
    The algorithm used is Argon2i, with a parallelism value of 1.
    Returns the encoded Argon2i hash according to the
    `Argon2 PHC Format
    <https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec.md>`_.
    If no `salt` is specified, then a random 16-byte salt
    is automatically generated.

    :param password: The password (:py:class:`bytes`)
    :param salt: Optional salt (:py:class:`bytes`), between 8 and 48 bytes.
    :param nb_blocks: Memory cost in KiB; should be at least 8. (:py:class:`int`)
    :param nb_iterations: Time cost; should be at least 1. (:py:class:`int`)
    :param hash_size: Length of hash in bytes, should be between 12 and 64.
                      For compatibility with :py:func:`.verify`, use 32 or 64.
                      (:py:class:`int`)
    :rtype: :py:class:`bytes`
    """

    if salt is None:
        salt = random(16)

    ensure_bytes('password', password)
    ensure_bytes('salt', salt)
    ensure_range('len(salt)', len(salt), 8, 48)
    ensure_range('hash_size', hash_size, 12, 64)

    digest = crypto_argon2i(
        password=password,
        salt=salt,
        hash_size=hash_size,
        nb_blocks=nb_blocks,
        nb_iterations=nb_iterations,
    )

    enc = '$argon2i$v={v}$m={M},t={T},p=1${salt}${digest}'.format(
        v='19',
        M=nb_blocks,
        T=nb_iterations,
        salt=_encode_base64(salt),
        digest=_encode_base64(digest),
    )
    return enc.encode('ascii')


def verify(password, hash):
    """
    Verifies the given `password` against the encoded `hash`.
    Note that since we only have Argon2i with parallelism value
    of 1, encoded hashes generated by other libraries / bindings
    might not be verifiable. In that case a :py:class:`.UnsupportedHashError`
    is raised.

    :param password: The password (:py:class:`bytes`).
    :param hash: The encoded hash (:py:class:`bytes`).
    :raises: :py:class:`RuntimeError`
    """

    ensure_bytes('password', password)
    ensure_bytes('hash', hash)

    match = argon2i_phc_format.match(hash.decode('ascii'))
    ensure(match is not None, UnsupportedHashError, 'unsupported hash')

    m, t, salt, digest = match.groups()
    m = int(m)
    t = int(t)

    ensure(m >= 8, UnsupportedHashError, 'invalid memory cost')
    ensure(t >= 1, UnsupportedHashError, 'invalid time cost')

    salt   = _decode_base64(salt)
    digest = _decode_base64(digest)

    ensure(len(salt) >= 8, UnsupportedHashError, 'invalid salt')
    ensure(len(digest) in {16, 32, 64}, UnsupportedHashError, 'unsupported digest length')

    hash_size = len(digest)
    actual = crypto_argon2i(
        password, salt=salt,
        nb_blocks=m, nb_iterations=t,
        hash_size=hash_size,
    )

    if hash_size == 16:
        return crypto_verify16(actual, digest)
    if hash_size == 32:
        return crypto_verify32(actual, digest)
    return crypto_verify64(actual, digest)
